
## «Основи програмного керування процесами в Unix-подібних ОС»

### 2.1 Перегляд інформації про процеси

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/2eca07b9-4484-4ebc-96d7-ba930be603db)

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/44e14de2-0d78-4d84-91ba-b18e3038c2b7)

2.1.1 Створити C-програму з назвою за шаблоном «ваше прізвище_process_info.c»,
наприклад, blazhko_process_info.c яка виводить на екран таку інформацію:
- ідентифікатор групи процесів, до якої належить процес;
- ідентифікатор процесу, що викликав цю функцію;
- ідентифікатор parent-процесу;
- ідентифікатор користувача процесу, який викликав цю функцію;
- ідентифікатор групи користувача процесу, який викликав цю функцію.
Скомпілювати створену С-програму та перевірити її роботу.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/49247003-ad7e-48f3-9a1d-f230b65ab771)

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/c406782f-47d3-42f6-bf7a-748fb487c313)

2.1.2 Запустити дві копії програми у двох режимах за прикладами з рисунку 4:
- паралельне виконання двох процесів;
- конвеєрне виконання двох процесів.

### 2.2 Створення child-процесу

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/3a4c4f56-7452-454b-95f9-4dc9ce3c193a)

2.2.1 Створити C-програму, яка породжує процес та замінює образ процесу на
команду у відповідності із варіантом з таблиці 3. Назва програми повинна співпадати з
назвою команди з таблиці 3, але з додатком у вигляді транслітерації вашого прізвища,
наприклад, touch_blazhko.c

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/f9242a14-d0f7-4d40-ad33-94fdd5af3532)

2.2.2 Скомпілювати програму та перевірити її роботу.

### 2.3 Обмін сигналами між процесами

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/88d14383-4770-4db6-898b-896686e332f8)

2.3.1 Створити C-програму з назвою «ваше прізвище_get_signal», в якій процес
очікує отримання сигналу SIGUSR2 та виводить повідомлення типу «Process of Students`
Surname got signal» після отримання сигналу, де замість слова Students` Surname в
повідомленні повинно бути ваше прізвище в транслітерації.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/8dc97d9f-ed8d-48ab-966e-99e036930b86)

2.3.2 Скомпілювати програму та запустити її.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/bf99586f-da0f-4a0c-b116-e4f1b7640f1c)

2.3.3 Використовуючи інший псевдотермінал, створити C-програму з назвою «ваше
прізвище_set_signal», яка надсилає сигнал SIGUSR2 процесу, запущеному в попередньому
пункті завдання.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/1df8fa7b-c4b9-4acf-aa47-8d63246b8b6e)

2.3.4 Скомпілювати другу створену С-програму та запустити її в іншому
псевдотерміналі, проаналізувавши повідомлення, які в першому псевдотерміналі виводить
перша програма.

### 2.4 Створення процесу-сироти

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/e022a3c9-a353-4e32-8e55-91800e567fd2)

2.4.1 Створити C-програму з назвою «ваше прізвище_orphan», в якій parent-процес
несподівано завершується раніше child-процесу. Parent-процес повинен очікувати
завершення n+1 секунд.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/1448ea50-39e9-48ab-8094-799892ce2455)

2.4.2 Скомпілювати програму та перевірити її роботу.

### 2.5 Створення zombie-процесу

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/362fdd89-800d-43f3-b644-136b6946f74d)

2.5.1 Створити C-програму з назвою «ваше прізвище_zombie.c», в якій child-процес
несподівано завершується раніше parent-процесу, перетворюється на zombie-процес,
виводячи в результаті повідомлення, наприклад, «I am Zombie-process of Students` Surname»,
за шаблоном як в попередньому завданні.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/ab02e311-9d97-4a12-a29d-df6fb8580419)

2.5.2 Скомпілювати програму та запустити її у фоновому режимі.

### 2.6 Попередження створення zombie-процесу

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/8456b37c-4fc4-4166-ae56-27aac9811de5)

2.6.1 Створити C-програму з назвою «ваше прізвище_zombie_stop.c», в якій child-
процес також як в попередньому завданні може перетворитися на zombie-процес, але ця
подія вже повинна контролюватися parent-процесом.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/36ec1029-f4c3-4b6f-8dbf-e7b941e9254d)

2.6.2 Скомпілювати програму та запустити її у фоновому режимі.

-------------------------------------------------------------------------------------------------------

## «Керування процесами-транзакціями в базах даних»

### 2.1 Теоретичне завдання зі створення історій виконання транзакцій

T1= W[K] R[B] W[B] C1
T2= R[M] R[B] W[M] C2
T3= R[K] W[K] C3

2.1.1 Створити історію квазіпаралельного успішного виконання транзакцій для
протоколу 1-го ступеня блокування.

H(T1,T2,T3) = X1[K] w1[K] r2[M] r3[k] r1[B] r2[B] X3[K]-Wait X1[B] w1[B] X2[M] w2[M] C1 U1 x3[K] w3[K] C2 U2 C3 U3

char* lock_table[][3] = {
{"K", "X1", "X3"},
{"B", "X1", ""},
{"M", "X2", ""}
};

2.1.2 Для створеної історії з попереднього завдання визначити наявність Deadlock-
стану транзакції, створивши граф очікування транзакцій, та зробити відповідний висновок.

int wait[1][2] = {1,3};

Немає DeadLock стану

2.1.3 Повторити завдання 2.1.1, але для протоколу 2-го ступеня блокування.

H(T1,T2,T3) = X1[K] w1[K] s2[M] r2[M] s3[K]-Wait C1 U1 s3[K] r3[k] s2[B] r2[B] X3[K] w3[K] X2[M] w2[M] C3 U3 C2 U2

char* lock_table[][3] = {
{"K", "X1,X3", "S3"},
{"B", "S2", ""},
{"M", "S2,X2", ""}
};

2.1.4 Для створеної історії з попереднього завдання визначити наявність Deadlock-
стану транзакції, створивши граф очікування транзакцій, та зробити відповідник висновок.

H(T1,T2,T3) = X1[K] w1[K] s2[M] r2[M] s3[K]-Wait s1[B] R1[B] S2[B]-Wait x3[K]-wait x1[B] w1[B] x2[M] w2[M] C1 U1 S3[K] R3[K] S2[B] R2[B] X3[K] W3[K] C2 U2 C3 U3

int wait[1][2] = {{1,3},{1,2},{1,3}};

Немає DeadLock стану

### 2.2 Налаштування бази даних

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/2bd243ee-3a4d-482e-93d8-fc9bc039c993)

2.2.1 Встановити в ОС Linux програмний пакунок з СКБД PostgreSQL та підключитись до ОС від імені користувача postgres.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/856aee56-d88e-42c8-8a26-c718cd6bb6cc)

2.2.2 Створити БД із назвою за шаблоном «surname_db», де surname – ваше прізвище
транслітерацією, наприклад, blazhko_db;

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/79293fb3-3fc5-4fab-8790-f06b6fad04df)

2.2.3 Встановити з’єднання з БД від імені СКБД-користувача postgres.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/3a0adf5d-3bf4-421b-a3d9-d66c4bcf6f9d)

2.2.4 Виконати команди отримання імені поточного користувача СКБД та назви БД.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/44b32eb7-85dc-4c6b-8956-fc433a9183ee)

2.2.5 У відповідності із варіантом з таблиці 16 створити реляційну таблицю.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/70e8c4f1-13cd-459f-a116-e6164e7a4b22)

2.2.6 У відповідності із варіантом з таблиці 16 додати рядок в реляційну таблицю.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/9ab0c588-0d32-4d71-b952-c55c1149f5e8)

2.2.7 Створити ще одну операцію внесення рядка в таблицю, який буде відрізнятися
значеннями всіх змінних (стовпчиків) від прикладу з варіанту, а одна із змінних повинна
враховувати значення із транслітерацією вашого прізвища.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/2d65ab56-38cf-4c3e-82b8-ea69623695bc)

2.2.8 Переглянути зміст таблиці, враховуючи всі стовпчики всіх рядків таблиці.

### 2.3 Керування квазіпаралельним виконанням транзакцій з використанням
команд блокування

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/f92304f5-6c4d-433a-af67-bfc76aa388ac)

2.3.1 Створити файл з назвою за шаблоном «ваше прізвище_transaction_lock_1.sql»,
наприклад, blazhko_transaction_lock_1.sql, та додати до нього операції двох транзакцій,
кожна з яких повинна включати наступні операції:
- операція блокування для протоколу 1-го ступеня блокування;
- операція читання всіх стовпчиків першого рядку таблиці;
- операція зміни значення другого стовпчика таблиці у першому рядку;
- повторна операція читання всіх стовпчиків першого рядку таблиці;
- операція фіксації всіх виконаних операцій.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/1cf8b587-1b50-437f-9064-86fa778d2525)
![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/ee458c45-9c98-4d3b-bae6-b96e85c4eb83)

  2.3.2 У двох псевдотерміналах виконати операції транзакцій при їх
квазіпаралельному режимі роботи за умови, що одна з транзакція стартує першою.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/1fc82ef4-58fd-4e43-9978-3b1d324f6734)

2.3.3 Повторити роботу транзакцій, але у першій транзакції замість операції
фіксації виконати операцію скасування всіх операцій транзакції.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/e39f2981-3c7e-4396-913d-76518738d212)

2.3.4 Створити файл з назвою за шаблоном «ваше прізвище_transaction_lock_2.sql»,
наприклад, blazhko_transaction_lock_2.sql, зі змістом файлу, створеного у пункті 2.3.1, але
вже враховуючи протокол 2-го ступеня блокування.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/77864c4a-014d-4d26-afc2-f1e2097fb9a5)

2.3.5 Повторити роботу транзакцій з використанням протоколу 2-го ступеня
блокування, але з додатковим параметром NOWAIT.

### 2.4 Керування квазіпаралельним виконанням транзакцій при наявності
Deadlock-станів.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/5414d524-7dc8-4a12-9bd3-c941b6d83db7)

2.4.1 Створити файл з назвою за шаблоном «ваше прізвище_deadlock.sql»,
наприклад, blazhko_deadlock.sql, зі змістом файлу, створеного у пункті 2.3.1, але вже
модифікованого так, щоб транзакції призводили до Deadlock-стану.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/f7747e99-8ba2-4d81-85c8-92fd0bde27d0)

2.4.2 Виконати модифіковані транзакції.
