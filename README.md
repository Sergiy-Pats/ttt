-------------------------------------------------------------------------

## «Основи використання скриптової мови інтерпретатору оболонки командного рядку Unix-подібних ОС»

### 2.1 Створення скрипт-файлів з перегляду даних віртуальної файлової системи

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/9dd9d56b-ef9a-452d-b9fc-a0cf7029ad7c)

2.1.1 Створити скрипт-файл на скриптовій мові програмування Bash з назвою за шаблоном Прізвище транслітерацією + osparam, наприклад, blazhkoosparam.sh, який виводить на екран лише окремі дані про параметри поточного стану ОС з віртуальної файлової системи Procfs (подробиці у лабораторній роботі No7) у відповідності із варіантом, представленим у стовпчику «Параметр пам`яті або процесору» таблиці 3.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/a4b36fdc-0f6b-4ce3-830f-d1db1b10413c)

2.1.2 Для перевірки правильності роботи скрипт-файлу необхідно його протестувати:
- з одним параметром;
- із двома параметрами.

### 2.2 Створення скрипт-файлів з інтерактивного керування об’єктами

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/b88401fd-498d-42e4-9823-bc42d0643727)

2.2.1 Створити скрипт-файл на скриптовій мові програмування Bash, який виконує дії у відповідності з варіантом, представленим у стовпчику «Назва скрипт-файлу» таблиці 3:

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/4e7100f4-c278-4d54-bdb2-04480d226fb4)

2.2.2 Для перевірки правильності роботи скрипт-файлу необхідно його протестувати:

### 2.3 Автоматичне створення об’єктів ОС

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/dce01c92-bc8e-4461-b63e-0acbf17e869d)

2.3.1 Створити скрипт-файл на скриптовій мові програмування Bash з назвою за шаблоном Прізвище транслітерацією + osobjectgenerator, наприклад, blazhkoosgenerator.sh, який у циклі for автоматично створить (30+n) об’єктів ОС у відповідності із варіантом таблиці 4 (n – номер варіанту):

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/e11ea829-aa58-4b76-9118-a3f2760035c5)

2.3.2 Виконати скрипт-файл та виконати команду для виводу на екран списку об’єктів.

### 2.4 Складна обробка текстового файлу утилітою AWK

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/d0d9bec1-dc4c-4e8a-a9d0-7bb3cac5cfbb)

2.4.1 Використовуючи утиліту AWK та відповідні команди одного командного рядку,обробити потік даних у відповідності із варіантом таблиці 4:

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/f3c2a70a-ea18-4f66-a8f4-8e13963f15a9)

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/6f3558ce-4913-4838-b560-424ab8aea23d)

2.4.2 Повторити рішення попереднього завдання, описавши команди AWK в окремому
скрипт-файлі, який виконати у командному рядку самостійно без утиліти AWK.

-----------------------------------------------------------------------------

## «Основи програмного керування процесами в Unix-подібних ОС»

### 2.1 Перегляд інформації про процеси

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/2eca07b9-4484-4ebc-96d7-ba930be603db)

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/44e14de2-0d78-4d84-91ba-b18e3038c2b7)

2.1.1 Створити C-програму з назвою за шаблоном «ваше прізвище_process_info.c»,
наприклад, blazhko_process_info.c яка виводить на екран таку інформацію:
- ідентифікатор групи процесів, до якої належить процес;
- ідентифікатор процесу, що викликав цю функцію;
- ідентифікатор parent-процесу;
- ідентифікатор користувача процесу, який викликав цю функцію;
- ідентифікатор групи користувача процесу, який викликав цю функцію.
Скомпілювати створену С-програму та перевірити її роботу.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/49247003-ad7e-48f3-9a1d-f230b65ab771)

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/c406782f-47d3-42f6-bf7a-748fb487c313)

2.1.2 Запустити дві копії програми у двох режимах за прикладами з рисунку 4:
- паралельне виконання двох процесів;
- конвеєрне виконання двох процесів.

### 2.2 Створення child-процесу

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/3a4c4f56-7452-454b-95f9-4dc9ce3c193a)

2.2.1 Створити C-програму, яка породжує процес та замінює образ процесу на
команду у відповідності із варіантом з таблиці 3. Назва програми повинна співпадати з
назвою команди з таблиці 3, але з додатком у вигляді транслітерації вашого прізвища,
наприклад, touch_blazhko.c

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/f9242a14-d0f7-4d40-ad33-94fdd5af3532)

2.2.2 Скомпілювати програму та перевірити її роботу.

### 2.3 Обмін сигналами між процесами

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/88d14383-4770-4db6-898b-896686e332f8)

2.3.1 Створити C-програму з назвою «ваше прізвище_get_signal», в якій процес
очікує отримання сигналу SIGUSR2 та виводить повідомлення типу «Process of Students`
Surname got signal» після отримання сигналу, де замість слова Students` Surname в
повідомленні повинно бути ваше прізвище в транслітерації.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/8dc97d9f-ed8d-48ab-966e-99e036930b86)

2.3.2 Скомпілювати програму та запустити її.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/bf99586f-da0f-4a0c-b116-e4f1b7640f1c)

2.3.3 Використовуючи інший псевдотермінал, створити C-програму з назвою «ваше
прізвище_set_signal», яка надсилає сигнал SIGUSR2 процесу, запущеному в попередньому
пункті завдання.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/1df8fa7b-c4b9-4acf-aa47-8d63246b8b6e)

2.3.4 Скомпілювати другу створену С-програму та запустити її в іншому
псевдотерміналі, проаналізувавши повідомлення, які в першому псевдотерміналі виводить
перша програма.

### 2.4 Створення процесу-сироти

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/e022a3c9-a353-4e32-8e55-91800e567fd2)

2.4.1 Створити C-програму з назвою «ваше прізвище_orphan», в якій parent-процес
несподівано завершується раніше child-процесу. Parent-процес повинен очікувати
завершення n+1 секунд.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/1448ea50-39e9-48ab-8094-799892ce2455)

2.4.2 Скомпілювати програму та перевірити її роботу.

### 2.5 Створення zombie-процесу

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/362fdd89-800d-43f3-b644-136b6946f74d)

2.5.1 Створити C-програму з назвою «ваше прізвище_zombie.c», в якій child-процес
несподівано завершується раніше parent-процесу, перетворюється на zombie-процес,
виводячи в результаті повідомлення, наприклад, «I am Zombie-process of Students` Surname»,
за шаблоном як в попередньому завданні.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/ab02e311-9d97-4a12-a29d-df6fb8580419)

2.5.2 Скомпілювати програму та запустити її у фоновому режимі.

### 2.6 Попередження створення zombie-процесу

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/8456b37c-4fc4-4166-ae56-27aac9811de5)

2.6.1 Створити C-програму з назвою «ваше прізвище_zombie_stop.c», в якій child-
процес також як в попередньому завданні може перетворитися на zombie-процес, але ця
подія вже повинна контролюватися parent-процесом.

![image](https://github.com/Sergiy-Pats/ttt/assets/78663930/36ec1029-f4c3-4b6f-8dbf-e7b941e9254d)

2.6.2 Скомпілювати програму та запустити її у фоновому режимі.
